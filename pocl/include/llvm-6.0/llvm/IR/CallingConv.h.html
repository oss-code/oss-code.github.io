<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CallingConv.h source code [include/llvm-6.0/llvm/IR/CallingConv.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'include/llvm-6.0/llvm/IR/CallingConv.h'; var root_path = '../../../..'; var data_path = '../../../../../data';</script>
<script src='../../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>include</a>/<a href='../..'>llvm-6.0</a>/<a href='..'>llvm</a>/<a href='./'>IR</a>/<a href='CallingConv.h.html'>CallingConv.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//===- llvm/CallingConv.h - LLVM Calling Conventions ------------*- C++ -*-===//</i></td></tr>
<tr><th id="2">2</th><td><i>//</i></td></tr>
<tr><th id="3">3</th><td><i>//                     The LLVM Compiler Infrastructure</i></td></tr>
<tr><th id="4">4</th><td><i>//</i></td></tr>
<tr><th id="5">5</th><td><i>// This file is distributed under the University of Illinois Open Source</i></td></tr>
<tr><th id="6">6</th><td><i>// License. See LICENSE.TXT for details.</i></td></tr>
<tr><th id="7">7</th><td><i>//</i></td></tr>
<tr><th id="8">8</th><td><i>//===----------------------------------------------------------------------===//</i></td></tr>
<tr><th id="9">9</th><td><i>//</i></td></tr>
<tr><th id="10">10</th><td><i>// This file defines LLVM's set of calling conventions.</i></td></tr>
<tr><th id="11">11</th><td><i>//</i></td></tr>
<tr><th id="12">12</th><td><i>//===----------------------------------------------------------------------===//</i></td></tr>
<tr><th id="13">13</th><td></td></tr>
<tr><th id="14">14</th><td><u>#<span data-ppcond="14">ifndef</span> <span class="macro" data-ref="_M/LLVM_IR_CALLINGCONV_H">LLVM_IR_CALLINGCONV_H</span></u></td></tr>
<tr><th id="15">15</th><td><u>#define <dfn class="macro" id="_M/LLVM_IR_CALLINGCONV_H" data-ref="_M/LLVM_IR_CALLINGCONV_H">LLVM_IR_CALLINGCONV_H</dfn></u></td></tr>
<tr><th id="16">16</th><td></td></tr>
<tr><th id="17">17</th><td><b>namespace</b> <span class="namespace">llvm</span> {</td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><i class="doc">/// CallingConv Namespace - This namespace contains an enum with a value for</i></td></tr>
<tr><th id="20">20</th><td><i class="doc">/// the well-known calling conventions.</i></td></tr>
<tr><th id="21">21</th><td><i class="doc">///</i></td></tr>
<tr><th id="22">22</th><td><b>namespace</b> <span class="namespace">CallingConv</span> {</td></tr>
<tr><th id="23">23</th><td></td></tr>
<tr><th id="24">24</th><td>  <i class="doc">/// LLVM IR allows to use arbitrary numbers as calling convention identifiers.</i></td></tr>
<tr><th id="25">25</th><td>  <b>using</b> <dfn class="typedef" id="llvm::CallingConv::ID" title='llvm::CallingConv::ID' data-type='unsigned int' data-ref="llvm::CallingConv::ID">ID</dfn> = <em>unsigned</em>;</td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td>  <i class="doc">/// A set of enums which specify the assigned numeric values for known llvm</i></td></tr>
<tr><th id="28">28</th><td><i class="doc">  /// calling conventions.</i></td></tr>
<tr><th id="29">29</th><td><i class="doc">  /// <span class="command">@brief</span> LLVM Calling Convention Representation</i></td></tr>
<tr><th id="30">30</th><td>  <b>enum</b> {</td></tr>
<tr><th id="31">31</th><td>    <i class="doc">/// C - The default llvm calling convention, compatible with C.  This</i></td></tr>
<tr><th id="32">32</th><td><i class="doc">    /// convention is the only calling convention that supports varargs calls.</i></td></tr>
<tr><th id="33">33</th><td><i class="doc">    /// As with typical C calling conventions, the callee/caller have to</i></td></tr>
<tr><th id="34">34</th><td><i class="doc">    /// tolerate certain amounts of prototype mismatch.</i></td></tr>
<tr><th id="35">35</th><td>    <dfn class="enum" id="llvm::CallingConv::C" title='llvm::CallingConv::C' data-ref="llvm::CallingConv::C">C</dfn> = <var>0</var>,</td></tr>
<tr><th id="36">36</th><td></td></tr>
<tr><th id="37">37</th><td>    <i>// Generic LLVM calling conventions.  None of these calling conventions</i></td></tr>
<tr><th id="38">38</th><td><i>    // support varargs calls, and all assume that the caller and callee</i></td></tr>
<tr><th id="39">39</th><td><i>    // prototype exactly match.</i></td></tr>
<tr><th id="40">40</th><td><i></i></td></tr>
<tr><th id="41">41</th><td><i>    /// Fast - This calling convention attempts to make calls as fast as</i></td></tr>
<tr><th id="42">42</th><td><i>    /// possible (e.g. by passing things in registers).</i></td></tr>
<tr><th id="43">43</th><td>    <dfn class="enum" id="llvm::CallingConv::Fast" title='llvm::CallingConv::Fast' data-ref="llvm::CallingConv::Fast">Fast</dfn> = <var>8</var>,</td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td>    <i>// Cold - This calling convention attempts to make code in the caller as</i></td></tr>
<tr><th id="46">46</th><td><i>    // efficient as possible under the assumption that the call is not commonly</i></td></tr>
<tr><th id="47">47</th><td><i>    // executed.  As such, these calls often preserve all registers so that the</i></td></tr>
<tr><th id="48">48</th><td><i>    // call does not break any live ranges in the caller side.</i></td></tr>
<tr><th id="49">49</th><td>    <dfn class="enum" id="llvm::CallingConv::Cold" title='llvm::CallingConv::Cold' data-ref="llvm::CallingConv::Cold">Cold</dfn> = <var>9</var>,</td></tr>
<tr><th id="50">50</th><td></td></tr>
<tr><th id="51">51</th><td>    <i>// GHC - Calling convention used by the Glasgow Haskell Compiler (GHC).</i></td></tr>
<tr><th id="52">52</th><td>    <dfn class="enum" id="llvm::CallingConv::GHC" title='llvm::CallingConv::GHC' data-ref="llvm::CallingConv::GHC">GHC</dfn> = <var>10</var>,</td></tr>
<tr><th id="53">53</th><td></td></tr>
<tr><th id="54">54</th><td>    <i>// HiPE - Calling convention used by the High-Performance Erlang Compiler</i></td></tr>
<tr><th id="55">55</th><td><i>    // (HiPE).</i></td></tr>
<tr><th id="56">56</th><td>    <dfn class="enum" id="llvm::CallingConv::HiPE" title='llvm::CallingConv::HiPE' data-ref="llvm::CallingConv::HiPE">HiPE</dfn> = <var>11</var>,</td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td>    <i>// WebKit JS - Calling convention for stack based JavaScript calls</i></td></tr>
<tr><th id="59">59</th><td>    <dfn class="enum" id="llvm::CallingConv::WebKit_JS" title='llvm::CallingConv::WebKit_JS' data-ref="llvm::CallingConv::WebKit_JS">WebKit_JS</dfn> = <var>12</var>,</td></tr>
<tr><th id="60">60</th><td></td></tr>
<tr><th id="61">61</th><td>    <i>// AnyReg - Calling convention for dynamic register based calls (e.g.</i></td></tr>
<tr><th id="62">62</th><td><i>    // stackmap and patchpoint intrinsics).</i></td></tr>
<tr><th id="63">63</th><td>    <dfn class="enum" id="llvm::CallingConv::AnyReg" title='llvm::CallingConv::AnyReg' data-ref="llvm::CallingConv::AnyReg">AnyReg</dfn> = <var>13</var>,</td></tr>
<tr><th id="64">64</th><td></td></tr>
<tr><th id="65">65</th><td>    <i>// PreserveMost - Calling convention for runtime calls that preserves most</i></td></tr>
<tr><th id="66">66</th><td><i>    // registers.</i></td></tr>
<tr><th id="67">67</th><td>    <dfn class="enum" id="llvm::CallingConv::PreserveMost" title='llvm::CallingConv::PreserveMost' data-ref="llvm::CallingConv::PreserveMost">PreserveMost</dfn> = <var>14</var>,</td></tr>
<tr><th id="68">68</th><td></td></tr>
<tr><th id="69">69</th><td>    <i>// PreserveAll - Calling convention for runtime calls that preserves</i></td></tr>
<tr><th id="70">70</th><td><i>    // (almost) all registers.</i></td></tr>
<tr><th id="71">71</th><td>    <dfn class="enum" id="llvm::CallingConv::PreserveAll" title='llvm::CallingConv::PreserveAll' data-ref="llvm::CallingConv::PreserveAll">PreserveAll</dfn> = <var>15</var>,</td></tr>
<tr><th id="72">72</th><td></td></tr>
<tr><th id="73">73</th><td>    <i>// Swift - Calling convention for Swift.</i></td></tr>
<tr><th id="74">74</th><td>    <dfn class="enum" id="llvm::CallingConv::Swift" title='llvm::CallingConv::Swift' data-ref="llvm::CallingConv::Swift">Swift</dfn> = <var>16</var>,</td></tr>
<tr><th id="75">75</th><td></td></tr>
<tr><th id="76">76</th><td>    <i>// CXX_FAST_TLS - Calling convention for access functions.</i></td></tr>
<tr><th id="77">77</th><td>    <dfn class="enum" id="llvm::CallingConv::CXX_FAST_TLS" title='llvm::CallingConv::CXX_FAST_TLS' data-ref="llvm::CallingConv::CXX_FAST_TLS">CXX_FAST_TLS</dfn> = <var>17</var>,</td></tr>
<tr><th id="78">78</th><td></td></tr>
<tr><th id="79">79</th><td>    <i>// Target - This is the start of the target-specific calling conventions,</i></td></tr>
<tr><th id="80">80</th><td><i>    // e.g. fastcall and thiscall on X86.</i></td></tr>
<tr><th id="81">81</th><td>    <dfn class="enum" id="llvm::CallingConv::FirstTargetCC" title='llvm::CallingConv::FirstTargetCC' data-ref="llvm::CallingConv::FirstTargetCC">FirstTargetCC</dfn> = <var>64</var>,</td></tr>
<tr><th id="82">82</th><td></td></tr>
<tr><th id="83">83</th><td>    <i class="doc">/// X86_StdCall - stdcall is the calling conventions mostly used by the</i></td></tr>
<tr><th id="84">84</th><td><i class="doc">    /// Win32 API. It is basically the same as the C convention with the</i></td></tr>
<tr><th id="85">85</th><td><i class="doc">    /// difference in that the callee is responsible for popping the arguments</i></td></tr>
<tr><th id="86">86</th><td><i class="doc">    /// from the stack.</i></td></tr>
<tr><th id="87">87</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_StdCall" title='llvm::CallingConv::X86_StdCall' data-ref="llvm::CallingConv::X86_StdCall">X86_StdCall</dfn> = <var>64</var>,</td></tr>
<tr><th id="88">88</th><td></td></tr>
<tr><th id="89">89</th><td>    <i class="doc">/// X86_FastCall - 'fast' analog of X86_StdCall. Passes first two arguments</i></td></tr>
<tr><th id="90">90</th><td><i class="doc">    /// in ECX:EDX registers, others - via stack. Callee is responsible for</i></td></tr>
<tr><th id="91">91</th><td><i class="doc">    /// stack cleaning.</i></td></tr>
<tr><th id="92">92</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_FastCall" title='llvm::CallingConv::X86_FastCall' data-ref="llvm::CallingConv::X86_FastCall">X86_FastCall</dfn> = <var>65</var>,</td></tr>
<tr><th id="93">93</th><td></td></tr>
<tr><th id="94">94</th><td>    <i class="doc">/// ARM_APCS - ARM Procedure Calling Standard calling convention (obsolete,</i></td></tr>
<tr><th id="95">95</th><td><i class="doc">    /// but still used on some targets).</i></td></tr>
<tr><th id="96">96</th><td>    <dfn class="enum" id="llvm::CallingConv::ARM_APCS" title='llvm::CallingConv::ARM_APCS' data-ref="llvm::CallingConv::ARM_APCS">ARM_APCS</dfn> = <var>66</var>,</td></tr>
<tr><th id="97">97</th><td></td></tr>
<tr><th id="98">98</th><td>    <i class="doc">/// ARM_AAPCS - ARM Architecture Procedure Calling Standard calling</i></td></tr>
<tr><th id="99">99</th><td><i class="doc">    /// convention (aka EABI). Soft float variant.</i></td></tr>
<tr><th id="100">100</th><td>    <dfn class="enum" id="llvm::CallingConv::ARM_AAPCS" title='llvm::CallingConv::ARM_AAPCS' data-ref="llvm::CallingConv::ARM_AAPCS">ARM_AAPCS</dfn> = <var>67</var>,</td></tr>
<tr><th id="101">101</th><td></td></tr>
<tr><th id="102">102</th><td>    <i class="doc">/// ARM_AAPCS_VFP - Same as ARM_AAPCS, but uses hard floating point ABI.</i></td></tr>
<tr><th id="103">103</th><td>    <dfn class="enum" id="llvm::CallingConv::ARM_AAPCS_VFP" title='llvm::CallingConv::ARM_AAPCS_VFP' data-ref="llvm::CallingConv::ARM_AAPCS_VFP">ARM_AAPCS_VFP</dfn> = <var>68</var>,</td></tr>
<tr><th id="104">104</th><td></td></tr>
<tr><th id="105">105</th><td>    <i class="doc">/// MSP430_INTR - Calling convention used for MSP430 interrupt routines.</i></td></tr>
<tr><th id="106">106</th><td>    <dfn class="enum" id="llvm::CallingConv::MSP430_INTR" title='llvm::CallingConv::MSP430_INTR' data-ref="llvm::CallingConv::MSP430_INTR">MSP430_INTR</dfn> = <var>69</var>,</td></tr>
<tr><th id="107">107</th><td></td></tr>
<tr><th id="108">108</th><td>    <i class="doc">/// X86_ThisCall - Similar to X86_StdCall. Passes first argument in ECX,</i></td></tr>
<tr><th id="109">109</th><td><i class="doc">    /// others via stack. Callee is responsible for stack cleaning. MSVC uses</i></td></tr>
<tr><th id="110">110</th><td><i class="doc">    /// this by default for methods in its ABI.</i></td></tr>
<tr><th id="111">111</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_ThisCall" title='llvm::CallingConv::X86_ThisCall' data-ref="llvm::CallingConv::X86_ThisCall">X86_ThisCall</dfn> = <var>70</var>,</td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td>    <i class="doc">/// PTX_Kernel - Call to a PTX kernel.</i></td></tr>
<tr><th id="114">114</th><td><i class="doc">    /// Passes all arguments in parameter space.</i></td></tr>
<tr><th id="115">115</th><td>    <dfn class="enum" id="llvm::CallingConv::PTX_Kernel" title='llvm::CallingConv::PTX_Kernel' data-ref="llvm::CallingConv::PTX_Kernel">PTX_Kernel</dfn> = <var>71</var>,</td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td>    <i class="doc">/// PTX_Device - Call to a PTX device function.</i></td></tr>
<tr><th id="118">118</th><td><i class="doc">    /// Passes all arguments in register or parameter space.</i></td></tr>
<tr><th id="119">119</th><td>    <dfn class="enum" id="llvm::CallingConv::PTX_Device" title='llvm::CallingConv::PTX_Device' data-ref="llvm::CallingConv::PTX_Device">PTX_Device</dfn> = <var>72</var>,</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td>    <i class="doc">/// SPIR_FUNC - Calling convention for SPIR non-kernel device functions.</i></td></tr>
<tr><th id="122">122</th><td><i class="doc">    /// No lowering or expansion of arguments.</i></td></tr>
<tr><th id="123">123</th><td><i class="doc">    /// Structures are passed as a pointer to a struct with the byval attribute.</i></td></tr>
<tr><th id="124">124</th><td><i class="doc">    /// Functions can only call SPIR_FUNC and SPIR_KERNEL functions.</i></td></tr>
<tr><th id="125">125</th><td><i class="doc">    /// Functions can only have zero or one return values.</i></td></tr>
<tr><th id="126">126</th><td><i class="doc">    /// Variable arguments are not allowed, except for printf.</i></td></tr>
<tr><th id="127">127</th><td><i class="doc">    /// How arguments/return values are lowered are not specified.</i></td></tr>
<tr><th id="128">128</th><td><i class="doc">    /// Functions are only visible to the devices.</i></td></tr>
<tr><th id="129">129</th><td>    <dfn class="enum" id="llvm::CallingConv::SPIR_FUNC" title='llvm::CallingConv::SPIR_FUNC' data-ref="llvm::CallingConv::SPIR_FUNC">SPIR_FUNC</dfn> = <var>75</var>,</td></tr>
<tr><th id="130">130</th><td></td></tr>
<tr><th id="131">131</th><td>    <i class="doc">/// SPIR_KERNEL - Calling convention for SPIR kernel functions.</i></td></tr>
<tr><th id="132">132</th><td><i class="doc">    /// Inherits the restrictions of SPIR_FUNC, except</i></td></tr>
<tr><th id="133">133</th><td><i class="doc">    /// Cannot have non-void return values.</i></td></tr>
<tr><th id="134">134</th><td><i class="doc">    /// Cannot have variable arguments.</i></td></tr>
<tr><th id="135">135</th><td><i class="doc">    /// Can also be called by the host.</i></td></tr>
<tr><th id="136">136</th><td><i class="doc">    /// Is externally visible.</i></td></tr>
<tr><th id="137">137</th><td>    <dfn class="enum" id="llvm::CallingConv::SPIR_KERNEL" title='llvm::CallingConv::SPIR_KERNEL' data-ref="llvm::CallingConv::SPIR_KERNEL">SPIR_KERNEL</dfn> = <var>76</var>,</td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td>    <i class="doc">/// Intel_OCL_BI - Calling conventions for Intel OpenCL built-ins</i></td></tr>
<tr><th id="140">140</th><td>    <dfn class="enum" id="llvm::CallingConv::Intel_OCL_BI" title='llvm::CallingConv::Intel_OCL_BI' data-ref="llvm::CallingConv::Intel_OCL_BI">Intel_OCL_BI</dfn> = <var>77</var>,</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td>    <i class="doc">/// <span class="command">\brief</span> The C convention as specified in the x86-64 supplement to the</i></td></tr>
<tr><th id="143">143</th><td><i class="doc">    /// System V ABI, used on most non-Windows systems.</i></td></tr>
<tr><th id="144">144</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_64_SysV" title='llvm::CallingConv::X86_64_SysV' data-ref="llvm::CallingConv::X86_64_SysV">X86_64_SysV</dfn> = <var>78</var>,</td></tr>
<tr><th id="145">145</th><td></td></tr>
<tr><th id="146">146</th><td>    <i class="doc">/// <span class="command">\brief</span> The C convention as implemented on Windows/x86-64 and</i></td></tr>
<tr><th id="147">147</th><td><i class="doc">    /// AArch64. This convention differs from the more common</i></td></tr>
<tr><th id="148">148</th><td><i class="doc">    ///<span class="command"> \c</span> <span class="arg">X86_64_SysV</span> convention in a number of ways, most notably in</i></td></tr>
<tr><th id="149">149</th><td><i class="doc">    /// that XMM registers used to pass arguments are shadowed by GPRs,</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">    /// and vice versa.</i></td></tr>
<tr><th id="151">151</th><td><i class="doc">    /// On AArch64, this is identical to the normal C (AAPCS) calling</i></td></tr>
<tr><th id="152">152</th><td><i class="doc">    /// convention for normal functions, but floats are passed in integer</i></td></tr>
<tr><th id="153">153</th><td><i class="doc">    /// registers to variadic functions.</i></td></tr>
<tr><th id="154">154</th><td>    <dfn class="enum" id="llvm::CallingConv::Win64" title='llvm::CallingConv::Win64' data-ref="llvm::CallingConv::Win64">Win64</dfn> = <var>79</var>,</td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td>    <i class="doc">/// <span class="command">\brief</span> MSVC calling convention that passes vectors and vector aggregates</i></td></tr>
<tr><th id="157">157</th><td><i class="doc">    /// in SSE registers.</i></td></tr>
<tr><th id="158">158</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_VectorCall" title='llvm::CallingConv::X86_VectorCall' data-ref="llvm::CallingConv::X86_VectorCall">X86_VectorCall</dfn> = <var>80</var>,</td></tr>
<tr><th id="159">159</th><td></td></tr>
<tr><th id="160">160</th><td>    <i class="doc">/// <span class="command">\brief</span> Calling convention used by HipHop Virtual Machine (HHVM) to</i></td></tr>
<tr><th id="161">161</th><td><i class="doc">    /// perform calls to and from translation cache, and for calling PHP</i></td></tr>
<tr><th id="162">162</th><td><i class="doc">    /// functions.</i></td></tr>
<tr><th id="163">163</th><td><i class="doc">    /// HHVM calling convention supports tail/sibling call elimination.</i></td></tr>
<tr><th id="164">164</th><td>    <dfn class="enum" id="llvm::CallingConv::HHVM" title='llvm::CallingConv::HHVM' data-ref="llvm::CallingConv::HHVM">HHVM</dfn> = <var>81</var>,</td></tr>
<tr><th id="165">165</th><td></td></tr>
<tr><th id="166">166</th><td>    <i class="doc">/// <span class="command">\brief</span> HHVM calling convention for invoking C/C++ helpers.</i></td></tr>
<tr><th id="167">167</th><td>    <dfn class="enum" id="llvm::CallingConv::HHVM_C" title='llvm::CallingConv::HHVM_C' data-ref="llvm::CallingConv::HHVM_C">HHVM_C</dfn> = <var>82</var>,</td></tr>
<tr><th id="168">168</th><td></td></tr>
<tr><th id="169">169</th><td>    <i class="doc">/// X86_INTR - x86 hardware interrupt context. Callee may take one or two</i></td></tr>
<tr><th id="170">170</th><td><i class="doc">    /// parameters, where the 1st represents a pointer to hardware context frame</i></td></tr>
<tr><th id="171">171</th><td><i class="doc">    /// and the 2nd represents hardware error code, the presence of the later</i></td></tr>
<tr><th id="172">172</th><td><i class="doc">    /// depends on the interrupt vector taken. Valid for both 32- and 64-bit</i></td></tr>
<tr><th id="173">173</th><td><i class="doc">    /// subtargets.</i></td></tr>
<tr><th id="174">174</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_INTR" title='llvm::CallingConv::X86_INTR' data-ref="llvm::CallingConv::X86_INTR">X86_INTR</dfn> = <var>83</var>,</td></tr>
<tr><th id="175">175</th><td></td></tr>
<tr><th id="176">176</th><td>    <i class="doc">/// Used for AVR interrupt routines.</i></td></tr>
<tr><th id="177">177</th><td>    <dfn class="enum" id="llvm::CallingConv::AVR_INTR" title='llvm::CallingConv::AVR_INTR' data-ref="llvm::CallingConv::AVR_INTR">AVR_INTR</dfn> = <var>84</var>,</td></tr>
<tr><th id="178">178</th><td></td></tr>
<tr><th id="179">179</th><td>    <i class="doc">/// Calling convention used for AVR signal routines.</i></td></tr>
<tr><th id="180">180</th><td>    <dfn class="enum" id="llvm::CallingConv::AVR_SIGNAL" title='llvm::CallingConv::AVR_SIGNAL' data-ref="llvm::CallingConv::AVR_SIGNAL">AVR_SIGNAL</dfn> = <var>85</var>,</td></tr>
<tr><th id="181">181</th><td></td></tr>
<tr><th id="182">182</th><td>    <i class="doc">/// Calling convention used for special AVR rtlib functions</i></td></tr>
<tr><th id="183">183</th><td><i class="doc">    /// which have an "optimized" convention to preserve registers.</i></td></tr>
<tr><th id="184">184</th><td>    <dfn class="enum" id="llvm::CallingConv::AVR_BUILTIN" title='llvm::CallingConv::AVR_BUILTIN' data-ref="llvm::CallingConv::AVR_BUILTIN">AVR_BUILTIN</dfn> = <var>86</var>,</td></tr>
<tr><th id="185">185</th><td></td></tr>
<tr><th id="186">186</th><td>    <i class="doc">/// Calling convention used for Mesa vertex shaders, or AMDPAL last shader</i></td></tr>
<tr><th id="187">187</th><td><i class="doc">    /// stage before rasterization (vertex shader if tessellation and geometry</i></td></tr>
<tr><th id="188">188</th><td><i class="doc">    /// are not in use, or otherwise copy shader if one is needed).</i></td></tr>
<tr><th id="189">189</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_VS" title='llvm::CallingConv::AMDGPU_VS' data-ref="llvm::CallingConv::AMDGPU_VS">AMDGPU_VS</dfn> = <var>87</var>,</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td>    <i class="doc">/// Calling convention used for Mesa/AMDPAL geometry shaders.</i></td></tr>
<tr><th id="192">192</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_GS" title='llvm::CallingConv::AMDGPU_GS' data-ref="llvm::CallingConv::AMDGPU_GS">AMDGPU_GS</dfn> = <var>88</var>,</td></tr>
<tr><th id="193">193</th><td></td></tr>
<tr><th id="194">194</th><td>    <i class="doc">/// Calling convention used for Mesa/AMDPAL pixel shaders.</i></td></tr>
<tr><th id="195">195</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_PS" title='llvm::CallingConv::AMDGPU_PS' data-ref="llvm::CallingConv::AMDGPU_PS">AMDGPU_PS</dfn> = <var>89</var>,</td></tr>
<tr><th id="196">196</th><td></td></tr>
<tr><th id="197">197</th><td>    <i class="doc">/// Calling convention used for Mesa/AMDPAL compute shaders.</i></td></tr>
<tr><th id="198">198</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_CS" title='llvm::CallingConv::AMDGPU_CS' data-ref="llvm::CallingConv::AMDGPU_CS">AMDGPU_CS</dfn> = <var>90</var>,</td></tr>
<tr><th id="199">199</th><td></td></tr>
<tr><th id="200">200</th><td>    <i class="doc">/// Calling convention for AMDGPU code object kernels.</i></td></tr>
<tr><th id="201">201</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_KERNEL" title='llvm::CallingConv::AMDGPU_KERNEL' data-ref="llvm::CallingConv::AMDGPU_KERNEL">AMDGPU_KERNEL</dfn> = <var>91</var>,</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td>    <i class="doc">/// Register calling convention used for parameters transfer optimization</i></td></tr>
<tr><th id="204">204</th><td>    <dfn class="enum" id="llvm::CallingConv::X86_RegCall" title='llvm::CallingConv::X86_RegCall' data-ref="llvm::CallingConv::X86_RegCall">X86_RegCall</dfn> = <var>92</var>,</td></tr>
<tr><th id="205">205</th><td></td></tr>
<tr><th id="206">206</th><td>    <i class="doc">/// Calling convention used for Mesa/AMDPAL hull shaders (= tessellation</i></td></tr>
<tr><th id="207">207</th><td><i class="doc">    /// control shaders).</i></td></tr>
<tr><th id="208">208</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_HS" title='llvm::CallingConv::AMDGPU_HS' data-ref="llvm::CallingConv::AMDGPU_HS">AMDGPU_HS</dfn> = <var>93</var>,</td></tr>
<tr><th id="209">209</th><td></td></tr>
<tr><th id="210">210</th><td>    <i class="doc">/// Calling convention used for special MSP430 rtlib functions</i></td></tr>
<tr><th id="211">211</th><td><i class="doc">    /// which have an "optimized" convention using additional registers.</i></td></tr>
<tr><th id="212">212</th><td>    <dfn class="enum" id="llvm::CallingConv::MSP430_BUILTIN" title='llvm::CallingConv::MSP430_BUILTIN' data-ref="llvm::CallingConv::MSP430_BUILTIN">MSP430_BUILTIN</dfn> = <var>94</var>,</td></tr>
<tr><th id="213">213</th><td></td></tr>
<tr><th id="214">214</th><td>    <i class="doc">/// Calling convention used for AMDPAL vertex shader if tessellation is in</i></td></tr>
<tr><th id="215">215</th><td><i class="doc">    /// use.</i></td></tr>
<tr><th id="216">216</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_LS" title='llvm::CallingConv::AMDGPU_LS' data-ref="llvm::CallingConv::AMDGPU_LS">AMDGPU_LS</dfn> = <var>95</var>,</td></tr>
<tr><th id="217">217</th><td></td></tr>
<tr><th id="218">218</th><td>    <i class="doc">/// Calling convention used for AMDPAL shader stage before geometry shader</i></td></tr>
<tr><th id="219">219</th><td><i class="doc">    /// if geometry is in use. So either the domain (= tessellation evaluation)</i></td></tr>
<tr><th id="220">220</th><td><i class="doc">    /// shader if tessellation is in use, or otherwise the vertex shader.</i></td></tr>
<tr><th id="221">221</th><td>    <dfn class="enum" id="llvm::CallingConv::AMDGPU_ES" title='llvm::CallingConv::AMDGPU_ES' data-ref="llvm::CallingConv::AMDGPU_ES">AMDGPU_ES</dfn> = <var>96</var>,</td></tr>
<tr><th id="222">222</th><td></td></tr>
<tr><th id="223">223</th><td>    <i class="doc">/// The highest possible calling convention ID. Must be some 2^k - 1.</i></td></tr>
<tr><th id="224">224</th><td>    <dfn class="enum" id="llvm::CallingConv::MaxID" title='llvm::CallingConv::MaxID' data-ref="llvm::CallingConv::MaxID">MaxID</dfn> = <var>1023</var></td></tr>
<tr><th id="225">225</th><td>  };</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td>} <i>// end namespace CallingConv</i></td></tr>
<tr><th id="228">228</th><td></td></tr>
<tr><th id="229">229</th><td>} <i>// end namespace llvm</i></td></tr>
<tr><th id="230">230</th><td></td></tr>
<tr><th id="231">231</th><td><u>#<span data-ppcond="14">endif</span> // LLVM_IR_CALLINGCONV_H</u></td></tr>
<tr><th id="232">232</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../../../../pocl/lib/CL/devices/cuda/pocl-ptx-gen.cc.html'>pocl/lib/CL/devices/cuda/pocl-ptx-gen.cc</a><br/>Generated on <em>2019-Oct-28</em> from project include<br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
