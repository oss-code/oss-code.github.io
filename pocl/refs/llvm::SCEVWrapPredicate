<inh f='include/llvm-6.0/llvm/Analysis/ScalarEvolution.h' l='182' c='llvm::SCEVPredicate'/>
<def f='include/llvm-6.0/llvm/Analysis/ScalarEvolution.h' l='286' ll='373'/>
<size>56</size>
<doc f='include/llvm-6.0/llvm/Analysis/ScalarEvolution.h' l='276'>/// This class represents an assumption made on an AddRec expression. Given an
/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw
/// flags (defined below) in the first X iterations of the loop, where X is a
/// SCEV expression returned by getPredicatedBackedgeTakenCount).
///
/// Note that this does not imply that X is equal to the backedge taken
/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a
/// predicated backedge taken count of X, we only guarantee that {0,+,1} has
/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we
/// have more than X iterations.</doc>
<fun r='_ZN4llvm17SCEVWrapPredicate10clearFlagsENS0_18IncrementWrapFlagsES1_'/>
<fun r='_ZN4llvm17SCEVWrapPredicate9maskFlagsENS0_18IncrementWrapFlagsEi'/>
<fun r='_ZN4llvm17SCEVWrapPredicate8setFlagsENS0_18IncrementWrapFlagsES1_'/>
<fun r='_ZN4llvm17SCEVWrapPredicate15getImpliedFlagsEPKNS_14SCEVAddRecExprERNS_15ScalarEvolutionE'/>
<mbr r='llvm::SCEVWrapPredicate::AR' o='320' t='const llvm::SCEVAddRecExpr *'/>
<mbr r='llvm::SCEVWrapPredicate::Flags' o='384' t='llvm::SCEVWrapPredicate::IncrementWrapFlags'/>
<fun r='_ZN4llvm17SCEVWrapPredicateC1ENS_19FoldingSetNodeIDRefEPKNS_14SCEVAddRecExprENS0_18IncrementWrapFlagsE'/>
<fun r='_ZNK4llvm17SCEVWrapPredicate8getFlagsEv'/>
<fun r='_ZNK4llvm17SCEVWrapPredicate7getExprEv'/>
<fun r='_ZNK4llvm17SCEVWrapPredicate7impliesEPKNS_13SCEVPredicateE'/>
<fun r='_ZNK4llvm17SCEVWrapPredicate5printERNS_11raw_ostreamEj'/>
<fun r='_ZNK4llvm17SCEVWrapPredicate12isAlwaysTrueEv'/>
<fun r='_ZN4llvm17SCEVWrapPredicate7classofEPKNS_13SCEVPredicateE'/>
