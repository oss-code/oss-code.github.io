<dec f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1390'/>
<use f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1409' u='c'/>
<use f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1410' u='c'/>
<use f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1411' u='c'/>
<use f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1412' u='c'/>
<doc f='include/llvm-6.0/llvm/Support/YAMLTraits.h' l='1382'>/// YAML I/O does conversion based on types. But often native data types
/// are just a typedef of built in intergral types (e.g. int).  But the C++
/// type matching system sees through the typedef and all the typedefed types
/// look like a built in type. This will cause the generic YAML I/O conversion
/// to be used. To provide better control over the YAML conversion, you can
/// use this macro instead of typedef.  It will create a class with one field
/// and automatic conversion operators to and from the base type.
/// Based on BOOST_STRONG_TYPEDEF</doc>
