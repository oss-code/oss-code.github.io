<dec f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='142' type='const llvm::SCEV *const *'/>
<use f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='147' u='w' c='_ZN4llvm12SCEVNAryExprC1ENS_19FoldingSetNodeIDRefENS_9SCEVTypesEPKPKNS_4SCEVEm'/>
<use f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='154' u='r' c='_ZNK4llvm12SCEVNAryExpr10getOperandEj'/>
<use f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='160' u='r' c='_ZNK4llvm12SCEVNAryExpr8op_beginEv'/>
<use f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='161' u='r' c='_ZNK4llvm12SCEVNAryExpr6op_endEv'/>
<use f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='300' u='r' c='_ZNK4llvm14SCEVAddRecExpr8getStartEv'/>
<offset>256</offset>
<doc f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='138'>// Since SCEVs are immutable, ScalarEvolution allocates operand
    // arrays with its SCEVAllocator, so this class just needs a simple
    // pointer rather than a more elaborate vector-like data structure.
    // This also avoids the need for a non-trivial destructor.</doc>
