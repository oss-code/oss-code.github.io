<inh f='include/llvm-6.0/llvm/IR/ValueHandle.h' l='30' c='llvm::ValueHandleBase'/>
<def f='include/llvm-6.0/llvm/IR/ValueHandle.h' l='389' ll='429'/>
<ovr f='include/llvm-6.0/llvm/Analysis/AssumptionCache.h' l='52' c='llvm::AssumptionCache::AffectedValueCallbackVH'/>
<ovr f='include/llvm-6.0/llvm/Analysis/AssumptionCache.h' l='185' c='llvm::AssumptionCacheTracker::FunctionCallbackVH'/>
<ovr f='include/llvm-6.0/llvm/IR/ValueMap.h' l='243' c='llvm::ValueMapCallbackVH'/>
<size>32</size>
<doc f='include/llvm-6.0/llvm/IR/ValueHandle.h' l='382'>/// \brief Value handle with callbacks on RAUW and destruction.
///
/// This is a value handle that allows subclasses to define callbacks that run
/// when the underlying Value has RAUW called on it or is destroyed.  This
/// class can be used as the key of a map, as long as the user takes it out of
/// the map before calling setValPtr() (since the map has to rearrange itself
/// when the pointer changes).  Unlike ValueHandleBase, this class has a vtable.</doc>
<fun r='_ZN4llvm10CallbackVH6anchorEv'/>
<fun r='_ZN4llvm10CallbackVHD1Ev'/>
<fun r='_ZN4llvm10CallbackVHC1ERKS0_'/>
<fun r='_ZN4llvm10CallbackVHaSERKS0_'/>
<fun r='_ZN4llvm10CallbackVH9setValPtrEPNS_5ValueE'/>
<fun r='_ZN4llvm10CallbackVHC1Ev'/>
<fun r='_ZN4llvm10CallbackVHC1EPNS_5ValueE'/>
<fun r='_ZNK4llvm10CallbackVHcvPNS_5ValueEEv'/>
<fun r='_ZN4llvm10CallbackVH7deletedEv'/>
<fun r='_ZN4llvm10CallbackVH19allUsesReplacedWithEPNS_5ValueE'/>
<ovr f='include/llvm-6.0/llvm/Analysis/AliasSetTracker.h' l='325' c='llvm::AliasSetTracker::ASTCallbackVH'/>
<ovr f='include/llvm-6.0/llvm/Analysis/CFLAliasAnalysisUtils.h' l='24' c='llvm::cflaa::FunctionHandle'/>
<ovr f='include/llvm-6.0/llvm/Analysis/GlobalsModRef.h' l='60' c='llvm::GlobalsAAResult::DeletionCallbackHandle'/>
<ovr f='include/llvm-6.0/llvm/Analysis/ScalarEvolution.h' l='1018' c='llvm::ScalarEvolution::SCEVCallbackVH'/>
<ovr f='include/llvm-6.0/llvm/Analysis/ScalarEvolutionExpressions.h' l='402' c='llvm::SCEVUnknown'/>
