<dec f='include/llvm-6.0/llvm/Analysis/LazyCallGraph.h' l='788' type='SmallVector&lt;llvm::LazyCallGraph::RefSCC *, 1&gt; llvm::LazyCallGraph::RefSCC::insertIncomingRefEdge(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)'/>
<doc f='include/llvm-6.0/llvm/Analysis/LazyCallGraph.h' l='763'>/// Insert an edge whose source is in a descendant RefSCC and target is in
    /// this RefSCC.
    ///
    /// There must be an existing path from the target to the source in this
    /// case.
    ///
    /// NB! This is has the potential to be a very expensive function. It
    /// inherently forms a cycle in the prior RefSCC DAG and we have to merge
    /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which
    /// participate in the cycle can in the worst case require traversing every
    /// RefSCC in the graph. Every attempt is made to avoid that, but passes
    /// must still exercise caution calling this routine repeatedly.
    ///
    /// Also note that this can only insert ref edges. In order to insert
    /// a call edge, first insert a ref edge and then switch it to a call edge.
    /// These are intentionally kept as separate interfaces because each step
    /// of the operation invalidates a different set of data structures.
    ///
    /// This returns all the RefSCCs which were merged into the this RefSCC
    /// (the target&apos;s). This allows callers to invalidate any cached
    /// information.
    ///
    /// FIXME: We could possibly optimize this quite a bit for cases where the
    /// caller and callee are very nearby in the graph. See comments in the
    /// implementation for details, but that use case might impact users.</doc>
